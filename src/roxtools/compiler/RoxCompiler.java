package roxtools.compiler;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.tools.DiagnosticCollector;
import javax.tools.FileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.JavaCompiler;
import javax.tools.JavaCompiler.CompilationTask;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.JavaFileObject.Kind;
import javax.tools.SimpleJavaFileObject;
import javax.tools.StandardLocation;
import javax.tools.ToolProvider;

public class RoxCompiler<T> {
	
	private final ClassLoaderImpl classLoader;
	private final JavaCompiler compiler;
	private final List<String> options;

	private DiagnosticCollector<JavaFileObject> diagnostics;
	private final FileManagerImpl javaFileManager;

	public RoxCompiler(ClassLoader loader) {
		this(loader, new String[0]) ;
	}
	
	public RoxCompiler(ClassLoader loader, String... options) {
		this(loader,  null, options) ;
	}
	
	public RoxCompiler(ClassLoader loader, URL[] classpaths, String... options) {
		if (classpaths == null) {
			if ( loader instanceof URLClassLoader ) {
				URLClassLoader urlCp = (URLClassLoader) loader ;
				classpaths = urlCp.getURLs() ;
			}
		}
		
		compiler = ToolProvider.getSystemJavaCompiler();
		
		if (compiler == null) {
			throw new IllegalStateException("Cannot find the system Java compiler. Check that your class path includes tools.jar");
		}
		
		classLoader = new ClassLoaderImpl(loader);
		diagnostics = new DiagnosticCollector<JavaFileObject>();
		
		JavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);
		
		javaFileManager = new FileManagerImpl(fileManager, classLoader);

		this.options = new ArrayList<String>();
		for (String option : options) {
			this.options.add(option);
		}
		
		if ( classpaths != null && classpaths.length > 0 ) {
			String pathSep = System.getProperty("path.separator") ;
			
			StringBuilder str = new StringBuilder() ;
			
			for (URL cp : classpaths) {
				try {
					File cpFile = new File( cp.toURI() ) ;

					if (str.length() > 0) str.append(pathSep) ;
					str.append( cpFile.toString() ) ;
				}
				catch (Exception e) {
					e.printStackTrace() ;
				}
			}
			
			if ( str.length() > 0 ) {
				String sysClassPath = System.getProperty("java.class.path") ;
				
				this.options.add("-classpath") ;
				this.options.add(sysClassPath + pathSep + str.toString()) ;	
			}
				
		}
		
	}

	/**
	 * Compile Java source in <var>javaSource</name> and return the resulting
	 * class.
	 * <p>
	 * Thread safety: this method is thread safe if the <var>javaSource</var>
	 * and <var>diagnosticsList</var> are isolated to this thread.
	 * 
	 * @param qualifiedClassName
	 *            The fully qualified class name.
	 * @param javaSource
	 *            Complete java source, including a package statement and a
	 *            class, interface, or annotation declaration.
	 *            
	 * @return a Class which is generated by compiling the source
	 * @throws RoxCompilerException
	 *             if the source cannot be compiled - for example, if it
	 *             contains syntax or semantic errors or if dependent classes
	 *             cannot be found.
	 * @throws ClassCastException
	 *             if the generated class is not assignable to all the optional
	 *             <var>types</var>.
	 */
	public synchronized Class<T> compile(String qualifiedClassName, CharSequence javaSource) throws RoxCompilerException, ClassCastException {
		Map<String, CharSequence> classes = new HashMap<String, CharSequence>(1);
		classes.put(qualifiedClassName, javaSource);
		
		Map<String, Class<T>> compiled = compile(classes);
		Class<T> newClass = compiled.get(qualifiedClassName);
		
		return newClass ;
	}

	/**
	 * Compile multiple Java source strings and return a Map containing the
	 * resulting classes.
	 * <p>
	 * Thread safety: this method is thread safe if the <var>classes</var> and
	 * <var>diagnosticsList</var> are isolated to this thread.
	 * 
	 * @param classes
	 *            A Map whose keys are qualified class names and whose values
	 *            are the Java source strings containing the definition of the
	 *            class. A map value may be null, indicating that compiled class
	 *            is expected, although no source exists for it (it may be a
	 *            non-public class contained in one of the other strings.)
	 * 
	 * @return A mapping of qualified class names to their corresponding
	 *         classes. The map has the same keys as the input
	 *         <var>classes</var>; the values are the corresponding Class
	 *         objects.
	 * @throws RoxCompilerException
	 *             if the source cannot be compiled
	 */
	public synchronized Map<String, Class<T>> compile(Map<String, CharSequence> classes) throws RoxCompilerException {
		List<JavaFileObject> sources = new ArrayList<JavaFileObject>();
		
		for (Entry<String, CharSequence> entry : classes.entrySet()) {
			String qualifiedClassName = entry.getKey();
			CharSequence javaSource = entry.getValue();
			if (javaSource != null) {
				int dotPos = qualifiedClassName.lastIndexOf('.');
				String className = dotPos == -1 ? qualifiedClassName : qualifiedClassName.substring(dotPos + 1);
				String packageName = dotPos == -1 ? "" : qualifiedClassName.substring(0, dotPos);
				JavaFileObjectMemorySource source = new JavaFileObjectMemorySource(className, javaSource);
				sources.add(source);

				javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName, className + Kind.SOURCE.extension, source);
			}
		}
		
		DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>();
		
		CompilationTask task = compiler.getTask(null, javaFileManager, diagnostics, options, null, sources);
		
		Boolean result = task.call();
		if (result == null || !result.booleanValue()) {
			throw new RoxCompilerException("Compilation failed.", classes.keySet(), diagnostics);
		}
		
		try {
			Map<String, Class<T>> compiled = new HashMap<String, Class<T>>();
			for (String qualifiedClassName : classes.keySet()) {
				Class<T> newClass = loadClass(qualifiedClassName);
				compiled.put(qualifiedClassName, newClass);
			}
			return compiled;
		} catch (ClassNotFoundException e) {
			throw new RoxCompilerException(classes.keySet(), e, diagnostics);
		} catch (IllegalArgumentException e) {
			throw new RoxCompilerException(classes.keySet(), e, diagnostics);
		} catch (SecurityException e) {
			throw new RoxCompilerException(classes.keySet(), e, diagnostics);
		}
	}

	@SuppressWarnings("unchecked")
	public Class<T> loadClass(String qualifiedClassName) throws ClassNotFoundException {
		return (Class<T>) classLoader.loadClass(qualifiedClassName);
	}

	static URI toURI(String name) {
		try {
			return new URI(name);
		} catch (URISyntaxException e) {
			throw new RuntimeException(e);
		}
	}

	public ClassLoader getClassLoader() {
		return javaFileManager.getClassLoader();
	}
	

    ///////////////////////////////////////////////////////////////////////////////

	static final class FileManagerImpl extends ForwardingJavaFileManager<JavaFileManager> {
		private final ClassLoaderImpl classLoader;
		private final Map<URI, JavaFileObject> fileObjects = new HashMap<URI, JavaFileObject>();

		public FileManagerImpl(JavaFileManager fileManager, ClassLoaderImpl classLoader) {
			super(fileManager);
			this.classLoader = classLoader;
		}

		public ClassLoader getClassLoader() {
			return classLoader;
		}

		@Override
		public FileObject getFileForInput(Location location, String packageName, String relativeName) throws IOException {
			FileObject o = fileObjects.get(uri(location, packageName, relativeName));
			if (o != null) return o;
			return super.getFileForInput(location, packageName, relativeName);
		}

		public void putFileForInput(StandardLocation location, String packageName, String relativeName, JavaFileObject file) {
			fileObjects.put(uri(location, packageName, relativeName), file);
		}

		private URI uri(Location location, String packageName, String relativeName) {
			return RoxCompiler.toURI(location.getName() + '/' + packageName + '/' + relativeName);
		}

		@Override
		public JavaFileObject getJavaFileForOutput(Location location, String qualifiedName, Kind kind, FileObject outputFile) throws IOException {
			JavaFileObject file = new JavaFileObjectMemorySource(qualifiedName, kind);
			classLoader.add(qualifiedName, file);
			return file;
		}

		@Override
		public ClassLoader getClassLoader(JavaFileManager.Location location) {
			return classLoader;
		}
		
		@Override
		public String inferBinaryName(Location loc, JavaFileObject file) {
			try {
				String result;
				if (file instanceof JavaFileObjectMemorySource) result = file.getName();
				else if (file instanceof JavaFileObjectURLClass) result = file.getName();
				else result = super.inferBinaryName(loc, file);
				return result;
			} catch (RuntimeException e) {
				System.err.println("inferBinaryName error: "+ loc +" > "+ file);
				throw e ;
			}
		}

		@Override
		public Iterable<JavaFileObject> list(Location location, String packageName, Set<Kind> kinds, boolean recurse) throws IOException {
			Iterable<JavaFileObject> result = super.list(location, packageName, kinds, recurse);
			ArrayList<JavaFileObject> files = new ArrayList<JavaFileObject>();
			if (location == StandardLocation.CLASS_PATH && kinds.contains(JavaFileObject.Kind.CLASS)) {
				for (JavaFileObject file : fileObjects.values()) {
					if (file.getKind() == Kind.CLASS && file.getName().startsWith(packageName)) {
						files.add(file);
					}
				}
				files.addAll(classLoader.files());
			}
			else if (location == StandardLocation.SOURCE_PATH && kinds.contains(JavaFileObject.Kind.SOURCE)) {
				for (JavaFileObject file : fileObjects.values()) {
					if (file.getKind() == Kind.SOURCE && file.getName().startsWith(packageName)) {
						files.add(file);
					}
				}
			}
			
			for (JavaFileObject file : result) {
				files.add(file);
			}
			
			if (location == StandardLocation.CLASS_PATH && kinds.contains(JavaFileObject.Kind.CLASS)) {
				List<JavaFileObject> classes = getClasses(packageName, recurse) ;	
				
				for (JavaFileObject javaObj : classes) {
					if ( !containsComatibleJavaObjName(files, javaObj) ) {
						files.add(javaObj) ;
					}	
				}
			}
			
			return files;
		}
		
		private boolean containsComatibleJavaObjName(ArrayList<JavaFileObject> files , JavaFileObject javaObj) {
			String name = javaObj.getName().replaceFirst("\\.class$", "").replaceFirst("^.*?([^\\.]+)$", "$1") ;
			
			for (JavaFileObject javaFileObject : files) {
				String name2 = javaFileObject.getName().replaceFirst("\\.class$", "").replaceFirst("^.*?([^\\.]+)$", "$1") ;
					
				if ( name.equals(name2) ) return true ;
			}
			
			return false ;
		}
		
	    private List<JavaFileObject> getClasses(String packageName, boolean recurse) throws IOException {
	        String path = packageName.replace('.', '/');
	        Enumeration<URL> resources = classLoader.getResources(path);
	        
	        ArrayList<JavaFileObject> javaObjs = new ArrayList<JavaFileObject>() ;
	        
	        
	        while (resources.hasMoreElements()) {
	            URL resource = resources.nextElement();
	            getClassesFromPackage(packageName, resource, javaObjs, recurse) ;
	        }
	        
	        return javaObjs ;
	    }
	    
	    private void getClassesFromPackage(String packName, URL packURL, ArrayList<JavaFileObject> javaObjs, boolean recurse) throws IOException {
	    	
	    	String protocol = packURL.getProtocol() ;
	    	
	    	if ( protocol.equals("file") ) {
	    		File file;
				try {
					file = new File( packURL.toURI() );
				}
				catch (URISyntaxException e) {
					throw new IOException(e) ;
				}

	    		if ( !file.isDirectory() ) throw new IOException("Package URL not a directory: "+ packURL) ;
	    		
	    		File[] listFiles = file.listFiles() ;
	    		
	    		for (File classFile : listFiles) {
	    			if ( classFile.getName().endsWith(".class") ) {
	        			URL url = classFile.toURI().toURL() ;
	        			String className = url.getPath().replaceFirst("^.*?([^\\\\/]+)$", "$1") ;
	        			if (packName.length() > 0) className = packName +"."+ className ;
	        			className = className.replaceFirst(".class$", "") ;
	        			JavaFileObjectURLClass javaFileObjectURLClass = new JavaFileObjectURLClass(className, url) ;
	        			javaObjs.add(javaFileObjectURLClass) ;	
	    			}	
				}
	    	}
	    	else if ( protocol.equals("jar") ) {
	    		
	    		String classPackPrefix = packName+"." ;
	    		
	    		String jarExternalForm = packURL.toExternalForm().replaceFirst("^jar:", "").replaceFirst("!.*", "") ;
	    		
	    		URL jarURL = new URL( jarExternalForm ) ;

	    		List<String> jarClassesEntries = getJarClassesEntries(jarURL) ;
	    		
	    		for (String entryName : jarClassesEntries) {
					String className = entryName.replaceFirst(".class$", "").replaceAll("[\\\\/]", ".") ;
					
					boolean match = false ;
					
					if ( recurse ) {
						match = className.startsWith(classPackPrefix)  ;
					}
					else {
						String classPack = className.replaceFirst("\\.[^\\.]+$", "") ;
						
						match = classPack.equals(packName) ;
					}
					
					if (match) {
						URL classURL = new URL("jar:"+jarExternalForm+"!/"+entryName) ;

						JavaFileObjectURLClass javaFileObjectURLClass = new JavaFileObjectURLClass(className, classURL) ;
		    			javaObjs.add(javaFileObjectURLClass) ;
					}
	    		}
	    	}
	    	else {
	    		throw new UnsupportedOperationException("Unsupported protocol: "+ protocol) ;
	    	}
	    	
	    }
	    
	    private HashMap<URL, List<String>> jarEntriesCache = new HashMap<URL, List<String>>() ;
	    
	    private List<String> getJarClassesEntries(URL jarURL) throws IOException {
	    	
	    	synchronized (jarEntriesCache) {
	    		List<String> cachedEntries = jarEntriesCache.get(jarURL) ;
				
	    		if (cachedEntries != null) return cachedEntries ;
	    		
		    	ZipInputStream zin = new ZipInputStream( jarURL.openStream() ) ;
		
		    	ArrayList<String> classEntries = new ArrayList<String>() ;
		    	
				ZipEntry entry;
				while ((entry = zin.getNextEntry()) != null) {
					String entryName = entry.getName() ;
		
					if (entryName.endsWith(".class")) {
						classEntries.add(entryName) ;
					}
				}
				
				jarEntriesCache.put(jarURL, classEntries) ;
				
				return classEntries ;
	    	}
	    }
	    
	    
	}
	
    static final class JavaFileObjectMemorySource extends SimpleJavaFileObject {
    	private ByteArrayOutputStream byteCode;
    	private final CharSequence source;

    	JavaFileObjectMemorySource(String baseName, CharSequence source) {
    		super(RoxCompiler.toURI(baseName + Kind.SOURCE.extension), Kind.SOURCE);
    		this.source = source;
    	}

    	JavaFileObjectMemorySource(String name, Kind kind) {
    		super(RoxCompiler.toURI(name), kind);
    		source = null;
    	}

    	@Override
    	public CharSequence getCharContent(boolean ignoreEncodingErrors) throws UnsupportedOperationException {
    		if (source == null) throw new UnsupportedOperationException("getCharContent()");
    		return source;
    	}

    	@Override
    	public InputStream openInputStream() {
    		return new ByteArrayInputStream(getByteCode());
    	}

    	@Override
    	public OutputStream openOutputStream() {
    		byteCode = new ByteArrayOutputStream();
    		return byteCode;
    	}
    	
    	byte[] getByteCode() {
    		return byteCode.toByteArray();
    	}
    }

    static final class JavaFileObjectURLClass extends SimpleJavaFileObject {
    	private final URL classURL;

    	JavaFileObjectURLClass(String baseName, URL classURL) {
    		super(RoxCompiler.toURI(baseName + Kind.CLASS.extension), Kind.CLASS);
    		this.classURL = classURL;
    	}
    	
    	@Override
    	public InputStream openInputStream() {
    		try {
    			return this.classURL.openStream() ;
    		}
    		catch (Exception e) {
    			throw new RuntimeException(e) ;
    		}
    	}
    }

    static final class ClassLoaderImpl extends ClassLoader {
    	private final Map<String, JavaFileObject> classes = new HashMap<String, JavaFileObject>();
    	
    	ClassLoaderImpl(ClassLoader parentClassLoader) {
    		super(parentClassLoader);
    	}

    	Collection<JavaFileObject> files() {
    		return Collections.unmodifiableCollection(classes.values());
    	}

    	@Override
    	protected Class<?> findClass(String qualifiedClassName) throws ClassNotFoundException {
    		JavaFileObject file = classes.get(qualifiedClassName);
    		if (file != null) {
    			byte[] bytes = ((JavaFileObjectMemorySource) file).getByteCode();
    			return defineClass(qualifiedClassName, bytes, 0, bytes.length);
    		}
    		
    		// Workaround for "feature" in Java 6
    		// see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6434149
    		try {
    			Class<?> c = Class.forName(qualifiedClassName);
    			return c;
    		} catch (ClassNotFoundException nf) {
    			// Ignore and fall through
    		}
    		
    		return super.findClass(qualifiedClassName);
    	}

    	void add(String qualifiedClassName, JavaFileObject javaFile) {
    		classes.put(qualifiedClassName, javaFile);
    	}

    	@Override
    	protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    		return super.loadClass(name, resolve);
    	}

    	@Override
    	public InputStream getResourceAsStream(String name) {
    		if (name.endsWith(".class")) {
    			String qualifiedClassName = name.substring(0, name.length() - ".class".length()).replace('/', '.');
    			
    			JavaFileObjectMemorySource file = (JavaFileObjectMemorySource) classes.get(qualifiedClassName);
    			if (file != null) {
    				return new ByteArrayInputStream(file.getByteCode());
    			}
    		}
    		
    		return super.getResourceAsStream(name);
    	}

    	
    }
	
}


